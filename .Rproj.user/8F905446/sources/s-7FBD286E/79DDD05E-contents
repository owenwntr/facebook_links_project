---
title: "Measuring the effect of transnational social connectedness on 2016 EU Referendum vote"
author: "Owen Winter"
date: "16/11/2021"
output: html_document
---

```{r setup, include=FALSE, results= 'hide', message=FALSE}
list.of.packages <- c("tidyverse","ggbiplot","ggplot2", "haven","sf","labelled",
                      "lme4","readxl","pano","margins","corrplot","matrixStats",
                      "stringr","knitr","creditmodel","rticles")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

library(tidyverse)
library(ggbiplot)
library(ggplot2)
library(haven)
library(sf)
library(labelled)
library(lme4)
library(readxl)
library(pano)
library(margins)
library(corrplot)
library(matrixStats)
library(stringr)
library(knitr)
library(creditmodel)
library(rticles)
```

There is a broad literature on the social transmission of social and political values. In the digital age, the social connections along which political views might be transmitted can be quantified much more easy than previously. In this study, I investigate the effect of transnational social connectedness on EU Referendum voting intention using [Facebook's Social Connectedness Index (SCI)](https://dataforgood.facebook.com/dfg/docs/methodology-social-connectedness-index).

## The Social Connectedness Index

The SCI is created by Facebook by assigning Facebook users to geographic areas using information on their profiles, including profile data directly provided and Facebook activity which includes geographic information. The number of friendships of users between geographic areas is counted and scaled, areas with few friendships are dropped and random noise is added to ensure anonymity. The final SCI is the number of possible friendships in between two regions which are fulfilled, per billion:

$Social Connectedness_{i,j} = \frac{FB\_Connections_{i,j}}{FB\_Users_{i}*FB\_Users_{j}}$

The lowest level in the UK which SCI is measured at is [GADM regions](https://gadm.org/). I load the dataset of all GADM region pairs, which is very large, and subset only pairs including UK regions. Table 1 shows the highest SCI scores including UK regions. As expected, the highest scores are within-region.

```{r load data}
#links <- read.table(file = 'gadm1_nuts3_counties-gadm1_nuts3_counties-fb-social-connectedness-index-october-2021/gadm1_nuts3_counties_gadm1_nuts3_counties.tsv',
                    #sep = '\t', header = TRUE)

#links <- links[which((startsWith(links$user_loc, "UK"))&(!startsWith(links$user_loc, "UKR"))),]

#write.csv(links, "uk_users.csv")

links <- read.csv("uk_users.csv")

levels <- read.csv("gadm1_nuts3_counties-gadm1_nuts3_counties-fb-social-connectedness-index-october-2021/gadm1_nuts3_counties_levels.csv")

kable(head(links[order(-links$scaled_sci),]))

internal <- links[which(links$user_loc==links$fr_loc),]
```

To study the effect of transnational friendships, an EU-wide dataset is needed. Because Facebook does not share this information, the closest approximation is to use a population weighted average. This approach assumes that $Facebook\_Users_{i}$ in the equation above are approximately proportional to the population of region $i$. Obviously, this is not an ideal assumption, but it is necessary to combined the regions into more coherent units for this analysis. In the EU, GADM1 regions are concurrent with NUTs regions, so NUTs population data can be used.

```{r combine levels}

links$fr_level <- levels$level[match(links$fr_loc,levels$key)]

links$fr_level[which(startsWith(links$fr_loc,"AFG"))] <- "gadm1"
links$fr_level[which(startsWith(links$fr_loc,"MUS"))] <- "gadm1"
links$fr_level[which(is.na(links$fr_level))] <- "country"

#Load NUTS populations

nuts_populations <- read.csv("demo_r_pjanaggr3_1_Data.csv")
nuts_populations$geo_year <- paste(nuts_populations$GEO, nuts_populations$TIME)

#Find the earliest year (2016 or later) with valid population data for NUTS regions

minimum_year <- nuts_populations %>%
  dplyr::group_by(GEO) %>%
  dplyr::summarise(min = min(TIME[which(Value!=":")]))

#Create geo-year keys to merge

minimum_year$geo_year <- paste(minimum_year$GEO, minimum_year$min)

nuts_populations$include <- 0
nuts_populations$include[match(minimum_year$geo_year,nuts_populations$geo_year)] <- 1
nuts_populations$Value <- as.numeric(gsub(",", "", nuts_populations$Value))
pops <- nuts_populations[which(nuts_populations$include==1),]

links$weight <- 1

indexes <- match(links$fr_loc,pops$GEO)[which(!is.na(match(links$fr_loc,pops$GEO)))]

links$weight[which(!is.na(match(links$fr_loc,pops$GEO)))] <- pops$Value[indexes]

ggplot(links, aes(x=weight, y=scaled_sci)) +
  geom_point(alpha=0.01) +
  scale_y_continuous(trans="log") +
  scale_x_continuous(trans="log",limits=c(1000,NA)) +
  labs(x="Region Population", y="Social Connectedness Index") +
  geom_smooth()

```

Below is a table of UK NUTs regions and their scaled SCI with different countries, including the UK. Curiously, the most connected regions are UKN11 (Mid Ulster) and TLS (East Timor). An article by [The Belfast Telegraph](https://www.belfasttelegraph.co.uk/opinion/columnists/hard-working-respectful-and-warm-we-could-learn-from-our-timorese-guests-30377313.html) shows that there is a genuine connection here. However, the presence of Timor-Leste also shows the limitations of the SCI for considering the impact on UK voters. The SCI measures the proportion of all possible connections fulfilled, rather than the proportion of the UK area with friends in an area. In the East Timorese case, for example, it may be that a small minority of Mid Ulster residents have many East Timorese friends, rather than a large proportion of those in Mid Ulster having a connection to East Timor.


```{r countries}

links$fr_country <- sapply(strsplit(links$fr_loc, split = "(?<=[a-zA-Z])\\s*(?=[0-9])", perl = TRUE), `[`, 1)

france <- c("FRY","FRM","FRL","FRK","FRJ","FRI","FRH","FRG","FRF","FRE","FRD","FRC","FRB")

links$fr_country[which(links$fr_country %in% france)] <- "FR"

germany <- c("DE","DEA","DEB","DEC","DED","DEE","DEF","DEG")

links$fr_country[which(links$fr_country %in% germany)] <- "DE"

italy <- c("ITC","ITF","ITG","ITH","ITI")

links$fr_country[which(links$fr_country %in% italy)] <- "IT"

turkey <- c("TR","TRA","TRB","TRC")

links$fr_country[which(links$fr_country %in% turkey)] <- "TR"

united_kingdom <- c("UKC","UKD","UKE","UKF","UKG","UKH","UKI","UKJ","UKK","UKL",
                    "UKM","UKN")

links$fr_country[which(links$fr_country %in% united_kingdom)] <- "UK"

countries <- links %>%
  dplyr::group_by(user_loc,fr_country) %>%
  dplyr::summarise(mean = mean(scaled_sci),
                   weighted_mean = weighted.mean(scaled_sci,weight))

countries_fromuk <- countries[which((startsWith(countries$user_loc, "UK"))&
                                      (!startsWith(countries$user_loc, "UKR"))&
                                      (!startsWith(countries$fr_country, "UK"))),]

kable(countries_fromuk[order(-countries_fromuk$weighted_mean),])

```

Principal components analysis (PCA) can be used to describe the distribution of SCI with different countries across UK regions. Before performing the PCA, I log transform the data, to better reflect the exponential nature of social connections. The results show how there is significant correlation between countries along one scale (PC1), with areas with more transnational connections tending to have higher SCI scores across the board (with the sole exception of the Isle of Man). London's NUTs regions (starting UKI) have mostly very high scores on PC1, possibly reflecting the large international community. The Orkney Islands (UKM65) have the lowest score. PC2 explains much less variation, only 6.4%.

```{r biplot}

df <- data.frame(user_loc = unique(countries_fromuk$user_loc))

for (country in unique(countries_fromuk$fr_country)){
  df[country] <- NA
  for (region in unique(countries_fromuk$user_loc)){
    df[which(df$user_loc==region),country] = log(countries_fromuk[which((countries_fromuk$user_loc==region)&(countries_fromuk$fr_country==country)),"weighted_mean"][[1]])
  }
}

df.pca <- prcomp(df[,c(2:200)], center = TRUE,scale. = FALSE)

ggbiplot(df.pca, labels=df$user_loc)

```
Finally, I combine members of the EU to give a SCI score for UK NUTs regions with the EU overall. 
```{r eu members}

eu_members <- c("AT","BE","BG","HR","CY","DK","EE","FI","FR","DE","EL","HU","IE","IT",
        "LV","LT","LU","MT","NL","PL","PT","RO","SK","SV","ES","SE")

links$eu <- 0
links$eu[which(links$fr_country %in% eu_members)] <- 1

eu_links <- links[which(links$eu==1),] %>%
  dplyr::group_by(user_loc) %>%
  dplyr::summarise(mean = mean(scaled_sci),
                   weighted_mean = weighted.mean(scaled_sci,weight))

map <- read_sf("NUTS_Level_3_(January_2018)_Boundaries (1)")

map$eu_links <- eu_links$weighted_mean[match(eu_links$user_loc, map$nuts318cd)]

ggplot(data=map, aes(fill=eu_links)) +
  geom_sf(size=0) +
  scale_fill_gradient(trans="log",low="black", high="green") +
  labs(fill="Social \nConnectedness \nwith the EU27\n(log)\n") +
  theme_minimal()


```


``` {r internal map}

map$internal_links <- internal$scaled_sci[match(internal$user_loc, map$nuts318cd)]

ggplot(data=map, aes(fill=internal_links)) +
  geom_sf(size=0) +
  scale_fill_gradient(trans="log",low="black", high="green") +
  labs(fill="Internal \nConnectedness \n(log)\n") +
  theme_minimal()

```
```{r country maps}

ireland <- countries_fromuk[which(countries_fromuk$fr_country=="IE"),]

map$ireland <- ireland$weighted_mean[match(ireland$user_loc, map$nuts318cd)]

pakistan <- countries_fromuk[which(countries_fromuk$fr_country=="PAK"),]
map$pakistan <- pakistan$weighted_mean[match(pakistan$user_loc, map$nuts318cd)]

romania <- countries_fromuk[which(countries_fromuk$fr_country=="RO"),]
map$romania <- romania$weighted_mean[match(romania$user_loc, map$nuts318cd)]

gibraltar <- countries_fromuk[which(countries_fromuk$fr_country=="GIB"),]
map$gibraltar <- gibraltar$weighted_mean[match(gibraltar$user_loc, map$nuts318cd)]

spain <- countries_fromuk[which(countries_fromuk$fr_country=="ES"),]
map$spain <- spain$weighted_mean[match(spain$user_loc, map$nuts318cd)]

spain <- countries_fromuk[which(countries_fromuk$fr_country=="ES"),]
map$spain <- spain$weighted_mean[match(spain$user_loc, map$nuts318cd)]

ggplot(data=map, aes(fill=ireland)) +
  geom_sf(size=0) +
  scale_fill_gradient(trans="log", low="black", high="green") +
  theme_minimal() +
  labs(fill="Social \nConnectedness \nwith the Republic\n of Ireland\n (log)\n")

```

```{r europe maps}

europe <- read_sf("NUTS_RG_60M_2016_4326_LEVL_3.shp")

cornwall <- links[which((links$user_loc=="UKK30")&(links$fr_level=="nuts3")),]
europe$cornwall <- cornwall$scaled_sci[match(europe$NUTS_ID,cornwall$fr_loc)]

enfield <- links[which((links$user_loc=="UKI54")&(links$fr_level=="nuts3")),]
europe$enfield <- enfield$scaled_sci[match(europe$NUTS_ID,enfield$fr_loc)]

birmingham <- links[which((links$user_loc=="UKG31")&(links$fr_level=="nuts3")),]
europe$birmingham <- birmingham$scaled_sci[match(europe$NUTS_ID,birmingham$fr_loc)]

belfast <- links[which((links$user_loc=="UKN06")&(links$fr_level=="nuts3")),]
europe$belfast <- belfast$scaled_sci[match(europe$NUTS_ID,belfast$fr_loc)]

ggplot(europe, aes(geometry = geometry, fill=belfast)) +
  geom_sf(size=0) +
  xlim(c(-21.5,43)) +
  ylim(c(35,71)) +
  scale_fill_gradient(trans="log", low="black", high="green",
                      labels = scales::number_format(accuracy = 1)) +
  theme_minimal() +
  labs(fill="Social \nConnectedness \nto Belfast \n(log)\n")

```

## Distances

``` {r distances}

uk <- europe[which(europe$CNTR_CODE=="UK"),]
nonuk <- europe[which(europe$CNTR_CODE!="UK"),]

index <- st_nearest_feature(x = uk, y = nonuk)

nearest <- nonuk %>% slice(index)

distances <- st_distance(x = st_centroid(uk), y= nearest, by_element = TRUE)

map$distance <- distances[match(map$nuts318cd,uk$NUTS_ID)]

ggplot(data=map, aes(fill=as.numeric(distance))) +
  geom_sf(size=0) +
  scale_fill_gradient(low="black", high="green") +
  theme_minimal() +
  labs(fill="Distance\nfrom the EU (m)")

ggplot(data=map, aes(x=as.numeric(distance), y=eu_links)) +
  geom_point() +
  scale_y_continuous(trans="log") +
  labs(x="Distance from the EU (m)", y="Log( SCI score with EU )") +
  geom_smooth(method="lm") +
  geom_point(map[which(map$nuts318cd=="UKI32"),],mapping=aes(x=as.numeric(distance), y=eu_links),
             shape=1, col="green",size=4) +
  geom_text(map[which(map$nuts318cd=="UKI32"),],mapping=aes(x=as.numeric(distance)+50000,
                                                            y=eu_links,label="Westminster"),
             shape=1, col="black",size=4) +
  geom_point(map[which(map$nuts318cd=="UKG33"),],mapping=aes(x=as.numeric(distance), y=eu_links),
             shape=1, col="green",size=4) +
  geom_text(map[which(map$nuts318cd=="UKG33"),],mapping=aes(x=as.numeric(distance)+40000,
                                                            y=eu_links,label="Coventry"),
             shape=1, col="black",size=4) +
  geom_point(map[which(map$nuts318cd=="UKH11"),],mapping=aes(x=as.numeric(distance), y=eu_links),
             shape=1, col="green",size=4) +
  geom_text(map[which(map$nuts318cd=="UKH11"),],mapping=aes(x=as.numeric(distance)+50000,
                                                            y=eu_links,label="Peterborough"),
             shape=1, col="black",size=4) +
  geom_point(map[which(map$nuts318cd=="UKL11"),],mapping=aes(x=as.numeric(distance), y=eu_links),
             shape=1, col="red",size=4) +
  geom_text(map[which(map$nuts318cd=="UKL11"),],mapping=aes(x=as.numeric(distance)+40000,
                                                            y=eu_links,label="Ynys Mon"),
             shape=1, col="black",size=4) +
  geom_point(map[which(map$nuts318cd=="UKC11"),],mapping=aes(x=as.numeric(distance), y=eu_links),
             shape=1, col="red",size=4) +
  geom_text(map[which(map$nuts318cd=="UKC11"),],mapping=aes(x=as.numeric(distance)+40000,
                                                            y=eu_links,label="Hartlepool"),
             shape=1, col="black",size=4) +
  geom_point(map[which(map$nuts318cd=="UKN09"),],mapping=aes(x=as.numeric(distance), y=eu_links),
             shape=1, col="red",size=4) +
  geom_text(map[which(map$nuts318cd=="UKN09"),],mapping=aes(x=as.numeric(distance)+40000,
                                                            y=eu_links-20,label="North Down"),
             shape=1, col="black",size=4) +
  geom_point(map[which(map$nuts318cd=="UKN16"),],mapping=aes(x=as.numeric(distance), y=eu_links),
             shape=1, col="green",size=4) +
  geom_text(map[which(map$nuts318cd=="UKN16"),],mapping=aes(x=as.numeric(distance)+40000,
                                                            y=eu_links+20,label="Fermanagh"),
             shape=1, col="black",size=4)

```

## British Election Study

``` {r bes data}

la_lookup <- read.csv("Local_Authority_District_(December_2018)_to_NUTS3_to_NUTS2_to_NUTS1_(January_2018)_Lookup_in_United_Kingdom.csv")

bes <- read_dta("BES.dta")

bes <- bes[which(bes$wave9==1),]

irrelevant_waves <- c("W1","W2","W3","W4","W5","W6","W7","W8","W10","W11",
                      "W12","W13","W14","W15","W16","W17","W18","W19","W20","W21")

current <- endsWith(colnames(bes),"W1")

for (wave in irrelevant_waves){
  new <- endsWith(colnames(bes),wave)
  current <- rowAny(cbind(current,new))
}

bes <- bes[,!current]

bes$localauthority <- to_character(bes$oslauaW9)

bes$localauthority[which(bes$localauthority=="Argyll & Bute")] <- "Argyll and Bute"
bes$localauthority[which(bes$localauthority=="Armagh, Banbridge and Craigavon")] <- "Armagh City, Banbridge and Craigavon"
bes$localauthority[which(bes$localauthority=="Dumfries & Galloway")] <- "Dumfries and Galloway"
bes$localauthority[which(bes$localauthority=="Edinburgh, City of")] <- "City of Edinburgh"
bes$localauthority[which(bes$localauthority=="Eilean Siar")] <- "Na h-Eileanan Siar"
bes$localauthority[which(bes$localauthority=="North Down and Ards")] <- "Ards and North Down"
bes$localauthority[which(bes$localauthority=="Perth & Kinross")] <- "Perth and Kinross"
bes$localauthority[which(bes$localauthority=="Rhondda, Cynon, Taff")] <- "Rhondda Cynon Taf"
bes$localauthority[which(bes$localauthority=="Shepway")] <- "Folkestone and Hythe"
bes$localauthority[which(bes$localauthority=="The Vale of Glamorgan")] <- "Vale of Glamorgan"

bes$nuts3 <- la_lookup$NUTS318CD[match(bes$localauthority,la_lookup$LAD18NM)]

bes$eu_links <- eu_links$weighted_mean[match(bes$nuts3,eu_links$user_loc)]
bes$internal_links <- internal$scaled_sci[match(bes$nuts3,internal$user_loc)]
bes$distance <- map$distance[match(bes$nuts3,map$nuts318cd)]

bes$voted_leave <- NA
bes$voted_leave[which(bes$euRefVoteW9==0)] <- 0
bes$voted_leave[which(bes$euRefVoteW9==1)] <- 1

ggplot(bes, aes(x=eu_links, y=voted_leave)) +
  geom_smooth() +
  scale_x_continuous(trans="log") +
  labs(x="SCI Score with the EU (Log Scale)", y="Proportion Voting Leave")

```

```{r external data}

source("scripts/nuts_data.R", local = knitr::knit_global())

variables <- colnames(nuts3_data)[5:8]

bes[,variables] <- nuts3_data[match(bes$nuts3, nuts3_data$nuts3),variables]

```


``` {r validate bes}


nuts_euref <- bes %>%
  dplyr::group_by(nuts3) %>%
  dplyr::summarise(bes = weighted.mean(voted_leave, wt_new_W9,na.rm=TRUE),
                   count = n())

nuts_euref$true <- nuts3_data$pct_leave[match(nuts_euref$nuts3,nuts3_data$nuts3)]

nuts_euref$difference <- nuts_euref$bes - nuts_euref$true

nuts_euref$moe <- 1.96*sqrt(nuts_euref$bes*(1-nuts_euref$bes)/nuts_euref$count)

ggplot(data=nuts_euref, aes(x=true, y=bes)) +
  geom_point() +
  geom_abline(intercept=0, slope=1, col="red",lty=2) +
  geom_errorbar(data=nuts_euref, aes(x=true, ymin=bes-moe, ymax=bes+moe), alpha=0.5) +
  labs(x="True EU Referendum Result",y="BES Sample Proportion Voting Leave")


```
``` {r demo model}

summary(model_nolinks <- glmer(voted_leave ~ rescale(as.numeric(ageW9),to=c(0,1)) + 
                         (1|p_edlevelW9) + (1|p_ethnicityW9) + gender +
                         (1|p_country_birthW9) + (1|p_gross_personalW9) +
                         (1|p_gross_householdW9) + (1|p_socgradeW9) +
                         (1|p_paper_readW9) +
                         (1|gorW9) + (1|nuts3),
               data=bes, weight=wt_new_W9, family="binomial"))

resids <- data.frame(residuals(model_nolinks))
colnames(resids) <- "residual"
resids$eu_links <- bes$eu_links[as.numeric(row.names(model_nolinks@frame))]
resids$internal_links <- bes$internal_links[as.numeric(row.names(model_nolinks@frame))]
resids$fitted <- fitted.values(model_nolinks)
resids$nuts3 <- bes$nuts3[as.numeric(row.names(model_nolinks@frame))]
resids$weights <- bes$wt_new_W9[as.numeric(row.names(model_nolinks@frame))]

ggplot(resids, aes(x=eu_links, y=residual)) +
  scale_x_continuous() +
  geom_smooth()

nuts_pred <- resids %>% dplyr::group_by(nuts3) %>% dplyr::summarise(pred = weighted.mean(residual, weights))

nuts_pred$mean <- nuts_euref$mean[match(nuts_pred$nuts3,nuts_euref$nuts3)]
nuts_pred$difference <- nuts_pred$pred - nuts_pred$mean
nuts_pred$eu_links <- eu_links$weighted_mean[match(nuts_pred$nuts3, eu_links$user_loc)]

plot(nuts_pred$eu_links, nuts_pred$pred)
abline(lm(nuts_pred$pred ~ nuts_pred$eu_links))

map$residual <- nuts_pred$pred[match(map$nuts318cd, nuts_pred$nuts3)]

ggplot(map, aes(fill=residual)) +
  geom_sf()



```

```{r model}

summary(model <- glmer(voted_leave ~ rescale(as.numeric(ageW9),to=c(0,1)) + 
                         (1|p_edlevelW9) + (1|p_ethnicityW9) + gender +
                         (1|p_country_birthW9) + (1|p_gross_personalW9) +
                         (1|p_gross_householdW9) + (1|p_socgradeW9) +
                         (1|p_paper_readW9) +
                         (1|gorW9) + (1|nuts3) +
                         inflow16_pct + inflow_change + log(eu_links) + 
                         log(internal_links) + distance,
               data=bes, weight=wt_new_W9, family="binomial"))

summary(model <- glmer(voted_leave ~ rescale(as.numeric(ageW9),to=c(0,1)) + 
                         (1+log(eu_links)|p_edlevelW9) + (1|p_ethnicityW9) + gender +
                         (1|p_country_birthW9) + (1|p_gross_personalW9) +
                         (1|p_gross_householdW9) + (1|p_socgradeW9) +
                         (1|p_paper_readW9) +
                         (1|gorW9) + (1|nuts3) +
                         inflow16_pct + inflow_change + 
                         log(internal_links) + distance,
               data=bes, weight=wt_new_W9, family="binomial"))

```
